# Data Model: Enhanced Deployment & Operations

**Date**: 2025-11-06  
**Feature**: 002-enhanced-deployment  
**Purpose**: Extend Phase 1 data model with notification logging and provider testing entities

**Note**: This extends the data model from 001-notification-server. Entities from Phase 1 are referenced but not redefined.

## Extended Entities

### 1. Notification Log Entry (Persistent - NEW)

**Description**: Persisted record of every notification attempt in SQLite database for audit, troubleshooting, and history display.

**Fields**:
- `id` (integer, primary key, autoincrement): Unique log entry ID
- `provider_id` (string, required): Provider instance that handled this notification
- `provider_type` (string, required): Type of provider ("telegram", "email") for filtering
- `recipient` (string, required): Notification recipient (chat ID, email address)
- `message` (text, required): Full notification message content
- `subject` (string, optional): Email subject line (Email only)
- `metadata` (text, optional): JSON string of additional metadata
- `priority` (string, required, default: "normal"): Priority level ("low", "normal", "high")
- `status` (string, required): Delivery status
- `error_message` (text, optional): Full error details if delivery failed
- `attempts` (integer, default: 0): Number of delivery attempts made
- `created_at` (text, required): ISO8601 timestamp when notification was received
- `delivered_at` (text, optional): ISO8601 timestamp when successfully delivered
- `is_test` (boolean, default: false): Whether this was a test notification

**Status Values**:
- `"pending"`: Queued for delivery
- `"sent"`: Successfully delivered (renamed from "delivered" for consistency with Phase 1)
- `"failed"`: Delivery failed permanently
- `"retrying"`: Temporary failure, retrying

**Validation Rules**:
- `id` auto-generated by SQLite, unique
- `provider_id` references existing provider (soft constraint - provider may be deleted)
- `status` must be one of: ["pending", "sent", "failed", "retrying"]
- `priority` must be one of: ["low", "normal", "high"]
- `created_at` must be valid ISO8601 format
- `delivered_at` must be after `created_at` if present
- `attempts` must be non-negative integer
- `error_message` required when status is "failed"

**Schema** (SQLite):
```sql
CREATE TABLE IF NOT EXISTS notification_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    provider_id TEXT NOT NULL,
    provider_type TEXT NOT NULL,
    recipient TEXT NOT NULL,
    message TEXT NOT NULL,
    subject TEXT,
    metadata TEXT,  -- JSON string
    priority TEXT NOT NULL DEFAULT 'normal',
    status TEXT NOT NULL,
    error_message TEXT,
    attempts INTEGER NOT NULL DEFAULT 0,
    created_at TEXT NOT NULL,  -- ISO8601
    delivered_at TEXT,  -- ISO8601
    is_test INTEGER NOT NULL DEFAULT 0,  -- SQLite uses 0/1 for boolean
    
    -- Composite indexes for common query patterns (from research.md)
    INDEX idx_provider_created (provider_id, created_at DESC),
    INDEX idx_status_created (status, created_at DESC),
    INDEX idx_type_created (provider_type, created_at DESC),
    INDEX idx_created_id (created_at DESC, id DESC)  -- Cursor pagination
);

-- Enable Write-Ahead Logging for concurrent reads
PRAGMA journal_mode=WAL;
PRAGMA synchronous=NORMAL;
```

**State Transitions**:
```
[API Request] → pending (logged immediately on API receive)
pending → sent (after successful delivery)
pending → failed (after permanent failure or max retries)
pending → retrying (after transient failure)
retrying → sent (after successful retry)
retrying → failed (after max retries exhausted)
```

**Relationships**:
- References one Provider Instance (by provider_id)
- Created from one Notification Request (Phase 1 entity)
- Displayed in Notification History UI

**Retention Policy**:
- Default retention: 90 days (configurable via environment variable)
- Cleanup strategy: Daily cron or on-startup check
- Query: `DELETE FROM notification_logs WHERE created_at < datetime('now', '-90 days')`

---

### 2. Test Notification Request (Transient - NEW)

**Description**: User-initiated test of a provider configuration from the UI. Not a separate entity type - uses same Notification Log Entry with `is_test=true` flag.

**Fields**: Same as Notification Log Entry with:
- `is_test` (boolean): Always `true` for test notifications
- `recipient`: Uses provider's default test recipient (from config)
- `message`: Standardized test message with timestamp

**Test Message Templates**:
- **Telegram**: `"Test notification from notimulti server - [timestamp]"`
- **Email Subject**: `"Test from notimulti"`
- **Email Body**: `"Test notification from notimulti server - [timestamp]"`

**Behavior**:
- Triggered by UI "Test" button click on provider card
- Uses same notification sending pipeline as regular notifications
- Logged in notification_logs table with `is_test=1`
- Displayed in history with "test" badge/indicator

**Validation Rules**:
- Provider must exist and be in "active" or "error" state (can test errored providers)
- Provider configuration must be valid (validated before test attempt)
- Only one concurrent test per provider (enforced by UI state)

**API Flow**:
```
1. UI: POST /api/providers/{provider_id}/test
2. Backend: Validate provider exists and config valid
3. Backend: Create test notification request with is_test=true
4. Backend: Send via normal notification pipeline
5. Backend: Log result in notification_logs
6. Backend: Return success/failure immediately (synchronous)
7. UI: Display result with error details if failed
```

**Relationships**:
- Triggered for one Provider Instance
- Creates one Notification Log Entry (with is_test=true)
- Displayed in same History UI with visual distinction

---

### 3. Notification History Query (Transient - NEW)

**Description**: Query parameters for filtering and paginating notification history in the UI.

**Fields**:
- `provider_id` (string, optional): Filter by specific provider
- `provider_type` (string, optional): Filter by provider type ("telegram", "email")
- `status` (string, optional): Filter by delivery status
- `date_from` (string, optional): ISO8601 date - filter notifications after this date
- `date_to` (string, optional): ISO8601 date - filter notifications before this date
- `include_tests` (boolean, default: true): Whether to include test notifications
- `cursor` (integer, optional): Last notification ID seen (for cursor pagination)
- `page_size` (integer, default: 50): Number of results per page (max 100)
- `sort_order` (string, default: "desc"): Sort direction ("asc", "desc")

**Validation Rules**:
- `provider_type` must be one of: ["telegram", "email"] if provided
- `status` must be one of: ["pending", "sent", "failed", "retrying"] if provided
- `date_from` and `date_to` must be valid ISO8601 dates if provided
- `date_from` must be before `date_to` if both provided
- `page_size` must be between 1 and 100
- `sort_order` must be one of: ["asc", "desc"]

**Query Building**:
```go
func (r *Repository) BuildHistoryQuery(filters HistoryQuery) (string, []interface{}) {
    query := `SELECT * FROM notification_logs WHERE 1=1`
    args := []interface{}{}
    
    if filters.ProviderID != "" {
        query += " AND provider_id = ?"
        args = append(args, filters.ProviderID)
    }
    if filters.ProviderType != "" {
        query += " AND provider_type = ?"
        args = append(args, filters.ProviderType)
    }
    if filters.Status != "" {
        query += " AND status = ?"
        args = append(args, filters.Status)
    }
    if filters.DateFrom != "" {
        query += " AND created_at >= ?"
        args = append(args, filters.DateFrom)
    }
    if filters.DateTo != "" {
        query += " AND created_at <= ?"
        args = append(args, filters.DateTo)
    }
    if !filters.IncludeTests {
        query += " AND is_test = 0"
    }
    if filters.Cursor > 0 {
        query += " AND id < ?"
        args = append(args, filters.Cursor)
    }
    
    query += " ORDER BY created_at " + filters.SortOrder + ", id " + filters.SortOrder
    query += " LIMIT ?"
    args = append(args, filters.PageSize+1) // Fetch one extra to determine "has more"
    
    return query, args
}
```

**Response Format**:
```json
{
  "notifications": [
    {
      "id": 12345,
      "provider_id": "telegram-alerts",
      "provider_type": "telegram",
      "recipient": "-1001234567890",
      "message": "Alert: High CPU usage",
      "status": "sent",
      "created_at": "2025-11-06T10:30:00Z",
      "delivered_at": "2025-11-06T10:30:02Z",
      "is_test": false,
      "attempts": 1
    }
  ],
  "pagination": {
    "page_size": 50,
    "has_more": true,
    "next_cursor": 12294
  }
}
```

---

### 4. Provider Instance (Extended from Phase 1)

**Description**: Runtime representation extended to support testing capability.

**New Fields**:
- `last_test_at` (timestamp, optional): When this provider was last tested
- `last_test_status` (string, optional): Result of last test ("success", "failed")

**New Methods**:
- `Test() error`: Send test notification and return result
- `GetTestRecipient() string`: Get default test recipient from config

**Testing Behavior**:
- Test uses same `Send()` method as regular notifications
- Test result cached in `last_test_at` / `last_test_status` for UI display
- Concurrent test prevention: Check `last_test_at` is > 10 seconds ago

---

## Entity Relationships Diagram (Extended)

```
┌─────────────────────┐
│ Configuration File  │  (Phase 1)
│ (File System)       │
└──────────┬──────────┘
           │ 1:1
           ▼
┌─────────────────────┐
│ Provider Config     │  (Phase 1)
│ (Parsed JSON)       │
└──────────┬──────────┘
           │ 1:1
           ▼
┌─────────────────────┐       1:N        ┌─────────────────────┐
│ Provider Instance   │◄─────────────────┤ Notification Request│  (Phase 1)
│ (Runtime)           │                  │ (API Input)         │
│ + Test capability   │                  └──────────┬──────────┘
└──────────┬──────────┘                            │
           │                                        │ 1:1
           │ triggers test                          ▼
           │                           ┌─────────────────────────┐
           └──────────────────────────►│ Notification Log Entry  │  (NEW - Phase 2)
                                       │ (SQLite Persistent)     │
                                       │ - Regular notifications │
                                       │ - Test notifications    │
                                       └──────────┬──────────────┘
                                                  │
                                                  │ queried by
                                                  ▼
                                       ┌─────────────────────────┐
                                       │ Notification History    │  (NEW - Phase 2)
                                       │ Query (Transient)       │
                                       │ - Filters               │
                                       │ - Pagination            │
                                       └─────────────────────────┘
```

## Validation Summary

### Log Entry Validation (Write Time)
1. Required fields present (provider_id, recipient, message, status, created_at)
2. Status value valid
3. Priority value valid
4. Timestamps valid ISO8601 format
5. Delivered_at after created_at if present

### History Query Validation (API Time)
1. Provider filters valid (ID exists, type valid)
2. Status filter valid
3. Date range valid and logical
4. Page size within bounds (1-100)
5. Sort order valid

### Test Request Validation (API Time)
1. Provider exists and configuration valid
2. Provider not currently being tested (rate limiting)
3. Test recipient configured or can use default

## Error Handling

### Logging Errors
- **Database write failure**: Log error, continue processing (don't block notification sending per NFR-004)
- **Queue overflow**: Drop entry with error log (prevents memory exhaustion)
- **Invalid log data**: Log validation error, skip entry

### Query Errors
- **Invalid filters**: Return 400 with specific field errors
- **Database connection lost**: Return 503, retry with backoff
- **Query timeout**: Return 504, suggest narrowing filters

### Test Errors
- **Provider not found**: Return 404 with provider ID
- **Provider configuration invalid**: Return 400 with validation details
- **Test send failure**: Return 200 with error details in response body (not an API error)
- **Concurrent test**: Return 429 (Too Many Requests) with retry-after header

## Performance Considerations

### Indexes
- Composite indexes cover common filter combinations (provider + time, status + time)
- Cursor pagination index (created_at DESC, id DESC) for efficient paging

### Query Optimization
- Cursor-based pagination: O(log n + pageSize) vs OFFSET O(n)
- Index-only scans where possible
- EXPLAIN QUERY PLAN validation for all queries

### Write Optimization
- Async buffered writes: Non-blocking (per research.md)
- Batch inserts: 100 entries per transaction
- Periodic flush: Every 5 seconds

### Caching
- SQLite query cache: Automatic for hot queries
- No application-level cache needed: SQLite fast enough with proper indexes

## Migration from Phase 1

Phase 1 already includes `notification_logs` table schema in `backend/internal/storage/schema.go`. Phase 2 extends it:

**Changes Required**:
1. Add `is_test` column (default 0)
2. Add composite indexes for query optimization
3. Enable WAL mode for concurrent reads
4. Update status values to match ("sent" instead of "delivered")

**Migration Strategy**:
```sql
-- Check if table exists and add new columns
ALTER TABLE notification_logs ADD COLUMN is_test INTEGER NOT NULL DEFAULT 0;

-- Drop old indexes if exist
DROP INDEX IF EXISTS idx_notification_logs_provider_id;
DROP INDEX IF EXISTS idx_notification_logs_created_at;
DROP INDEX IF EXISTS idx_notification_logs_status;

-- Add new composite indexes
CREATE INDEX IF NOT EXISTS idx_provider_created ON notification_logs(provider_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_status_created ON notification_logs(status, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_type_created ON notification_logs(provider_type, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_created_id ON notification_logs(created_at DESC, id DESC);

-- Enable WAL mode
PRAGMA journal_mode=WAL;
PRAGMA synchronous=NORMAL;
```

**Backward Compatibility**: Existing logs remain valid. New `is_test` column defaults to 0 (false) for existing entries.
